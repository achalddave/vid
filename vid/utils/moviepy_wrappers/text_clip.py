import os
import subprocess as sp
import tempfile

from moviepy.config import get_setting
from moviepy.tools import subprocess_call
from moviepy.video.VideoClip import ImageClip
from moviepy.compat import DEVNULL

# TODO(achald): This still does not work! ImageMagick seems to disable the
# label protocol entirely on Trinity. I think the easiest fix is to just use
# PIL instead.


class TextClipNoFile():
    """Like moviepy's TextClip, but don't ask ImageMagick to read from file.

    Due to security concerns, ImageMagick by default won't allow reading label
    names from a file. The "fix" is to edit the security policy (see, e.g.
    https://github.com/Zulko/moviepy/issues/401), but this may not be desirable
    or possible. This class is exactly like moviepy's text clip, but removes
    support for the `filename` parameter, and always passes text directly
    on the command line.

    Class for autogenerated text clips.

    Creates an ImageClip originating from a script-generated text image.
    Requires ImageMagick.

    Parameters
    -----------

    txt
      A string of the text to write.

    size
      Size of the picture in pixels. Can be auto-set if
      method='label', but mandatory if method='caption'.
      the height can be None, it will then be auto-determined.

    bg_color
      Color of the background. See ``TextClip.list('color')``
      for a list of acceptable names.

    color
      Color of the text. See ``TextClip.list('color')`` for a
      list of acceptable names.

    font
      Name of the font to use. See ``TextClip.list('font')`` for
      the list of fonts you can use on your computer.

    stroke_color
      Color of the stroke (=contour line) of the text. If ``None``,
      there will be no stroke.

    stroke_width
      Width of the stroke, in pixels. Can be a float, like 1.5.

    method
      Either 'label' (default, the picture will be autosized so as to fit
      exactly the size) or 'caption' (the text will be drawn in a picture
      with fixed size provided with the ``size`` argument). If `caption`,
      the text will be wrapped automagically (sometimes it is buggy, not
      my fault, complain to the ImageMagick crew) and can be aligned or
      centered (see parameter ``align``).

    kerning
      Changes the default spacing between letters. For
      nstance ``kerning=-1`` will make the letters 1 pixel nearer from
      ach other compared to the default spacing.

    align
      center | East | West | South | North . Will only work if ``method``
      is set to ``caption``

    transparent
      ``True`` (default) if you want to take into account the
      transparency in the image.

    """
    def __init__(self, txt, size=None, color='black',
                 bg_color='transparent', fontsize=None, font='Courier',
                 stroke_color=None, stroke_width=1, method='label',
                 kerning=None, align='center', interline=None,
                 tempfilename=None, temptxt=None,
                 transparent=True, remove_temp=True,
                 print_cmd=False):
        if size is not None:
            size = ('' if size[0] is None else str(size[0]),
                    '' if size[1] is None else str(size[1]))

        cmd = ([get_setting("IMAGEMAGICK_BINARY"),
               "-background", bg_color,
                "-fill", color,
                "-font", font])

        if fontsize is not None:
            cmd += ["-pointsize", "%d" % fontsize]
        if kerning is not None:
            cmd += ["-kerning", "%0.1f" % kerning]
        if stroke_color is not None:
            cmd += ["-stroke", stroke_color, "-strokewidth",
                    "%.01f" % stroke_width]
        if size is not None:
            cmd += ["-size", "%sx%s" % (size[0], size[1])]
        if align is not None:
            cmd += ["-gravity", align]
        if interline is not None:
            cmd += ["-interline-spacing", "%d" % interline]

        if tempfilename is None:
            tempfile_fd, tempfilename = tempfile.mkstemp(suffix='.png')
            os.close(tempfile_fd)

        print(txt)
        cmd += ["%s:'%s'" % (method, txt),
                "-type", "truecolormatte", "PNG32:%s" % tempfilename]
        print(cmd)

        if print_cmd:
            print(" ".join(cmd))

        try:
            subprocess_call(cmd, verbose=False)
        except (IOError, OSError) as err:
            error = ("MoviePy Error: creation of %s failed because of the "
                     "following error:\n\n%s.\n\n." % (tempfilename, str(err))
                     + ("This error can be due to the fact that ImageMagick "
                        "is not installed on your computer, or (for Windows "
                        "users) that you didn't specify the path to the "
                        "ImageMagick binary in file conf.py, or that the path "
                        "you specified is incorrect"))
            raise IOError(error)

        ImageClip.__init__(self, tempfilename, transparent=transparent)
        self.txt = txt
        self.color = color
        self.stroke_color = stroke_color

        if remove_temp:
            if os.path.exists(tempfilename):
                os.remove(tempfilename)
            if os.path.exists(temptxt):
                os.remove(temptxt)

    @staticmethod
    def list(arg):
        """Returns the list of all valid entries for the argument of
        ``TextClip`` given (can be ``font``, ``color``, etc...) """

        popen_params = {"stdout": sp.PIPE,
                        "stderr": DEVNULL,
                        "stdin": DEVNULL}

        if os.name == "nt":
            popen_params["creationflags"] = 0x08000000

        process = sp.Popen([get_setting("IMAGEMAGICK_BINARY"),
                            '-list', arg], **popen_params)
        result = process.communicate()[0]
        lines = result.splitlines()

        if arg == 'font':
            return [l.decode('UTF-8')[8:] for l in lines if l.startswith(b"  Font:")]
        elif arg == 'color':
            return [l.split(b" ")[0] for l in lines[2:]]
        else:
            raise Exception("Moviepy:Error! Argument must equal "
                            "'font' or 'color'")

    @staticmethod
    def search(string, arg):
        """Returns the of all valid entries which contain ``string`` for the
           argument ``arg`` of ``TextClip``, for instance

           >>> # Find all the available fonts which contain "Courier"
           >>> print ( TextClip.search('Courier', 'font') )

        """
        string = string.lower()
        names_list = TextClipNoFile.list(arg)
        return [name for name in names_list if string in name.lower()]
